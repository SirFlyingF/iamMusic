from flask import jsonify, request, Response

from Commons.models import Playlist, Song
from Commons.database import session

class SearchAPI:
    endpoints = ['Search']
    def __init__(self, request):
        self.request = request

    def _register_API_hit(self, endpoint):
        return 0

    def _validate_request(self, endpoint):
        match endpoint:
            case 'Search':
                if self.request.query_string is None or self.request.query_string == "":
                    return False, "No query String", 400
                if {'entity', 'value'} >= self.request.args:
                    return False, "No query String", 400
                return True, "", 200
                
        return False, "Invalid Request", 400

    # Support both tese URLs formats:
    # /Search/album/Meliora
    # /Search?entity=album&value=Meliora
    # if value is not passed, return all
    def Search(self, entity=None, value=None):
        endpoint = 'Search'
        if not entity:
            valid, msg, http_code = _validate_request(endpoint)
            if not valid:
                return Response(msg, status=http_code)
        self._register_API_hit(endpoint)
        
        try: 
            if not entity or not value:
                entity = self.request.args.get('entity')
                value = self.request.args.get('value')

            if entity == 'playlist':
                q = session.query(Playlist)
                q = q.filter(
                        Playlist.name.like(f"{value}%")
                    )
                result = q.all()
                response = {'data': [pl.__serial__() for pl in result]}

            else:
                q = session.query(Song)
                match entity:
                    case 'album':
                        q = q.filter(Song.album.like(f"{value}%"))
                        q = q.order_by(Song.track_num)
                        result = q.all()

                        response = {'data':{}}
                        for song in result:
                            if song.album not in response['data']:
                                response['data'][song.album] = []
                            response['data'][song.album].append(song.__serial__())

                    case 'artist':
                        # Consider comma separated multiple
                        # song artists and 'ft' artists.
                        # %song_artist% is avoided as meaningless superstrings will also qualify
                        q = q.filter(
                                or_(
                                    Song.album_artist.like(f"{value}%"),
                                    Song.song_artist.like(f"{value}%"),
                                    Song.song_artist.like(f"%,_{value}%"),
                                    Song.song_artist.like(f"%ft_{value}%")
                                )
                            ).order_by(Song.track_num)
                        result = q.all()

                        response = {'data': []}
                        for song in result:
                            response['data'].append(song.__serial__())

                    case 'title':
                        q = q.filter(Song.title.like(f"{value}%"))
                        result = q.all()
                        response = {'data': [song.__serial__() for song in result]}
                        
        except Exception as e:
            return Response("Internal Server Error", status=500)
        return jsonify(response), 200


# Consider storing base64 encoded artwork in SQL table
#audio = ID3(song.path) 
#if 'APIC' not in audio:
#    response[song.album]['artwork'] = None
#else:
#    artwork = audio['APIC'] 
#    # t = {'b64':b64encode(bytes(artwork.data)).decode(), 'mime':artwork.mime}
#    response[song.album_name]['artwork'] = {'img' : artwork.data, 'mime' : artwork.mime}

